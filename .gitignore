import json
import csv
import matplotlib.pyplot as plt

def calculate_delay(R, C):
    """Calculates propagation delay: t_pd = 0.69 * R * C"""
    return 0.69 * R * C

def calculate_dynamic_power(alpha, C, V, f):
    """Calculates dynamic power: P_dyn = Î± * C * VÂ² * f"""
    return alpha * C * (V ** 2) * f

def calculate_static_power(I_leak, V):
    """Calculates static power: P_static = I_leak * V"""
    return I_leak * V

def get_scaling_factor(node_nm):
    """
    Returns scaling multiplier for R, C, V, and leakage based on node.
    Smaller nodes â†’ lower V, lower C, higher leakage
    """
    scaling_data = {
        180: {"V": 1.8, "C_scale": 1.0, "R_scale": 1.0, "leak_factor": 1},
        90:  {"V": 1.2, "C_scale": 0.6, "R_scale": 1.2, "leak_factor": 2},
        45:  {"V": 1.0, "C_scale": 0.4, "R_scale": 1.5, "leak_factor": 4},
        7:   {"V": 0.7, "C_scale": 0.2, "R_scale": 2.0, "leak_factor": 10}
    }
    return scaling_data.get(node_nm, scaling_data[180])  # default to 180nm

def load_gate_library(file="gates.json"):
    with open(file, 'r') as f:
        return json.load(f)

def save_to_csv(results, filename="results.csv"):
    keys = results[0].keys()
    with open(filename, 'w', newline='') as f:
        writer = csv.DictWriter(f, keys)
        writer.writeheader()
        writer.writerows(results)

def plot_delay_vs_node(delay_data):
    nodes = [item["Node (nm)"] for item in delay_data]
    delays = [item["Delay (s)"] for item in delay_data]

    plt.figure(figsize=(8, 5))
    plt.plot(nodes, delays, marker='o', color='blue')
    plt.title("Propagation Delay vs Technology Node")
    plt.xlabel("Technology Node (nm)")
    plt.ylabel("Delay (s)")
    plt.gca().invert_xaxis()
    plt.grid(True)
    plt.tight_layout()
    plt.show()

def plot_power_vs_frequency(freq_data):
    freqs = [item["Frequency (Hz)"] for item in freq_data]
    powers = [item["Dynamic Power (W)"] for item in freq_data]

    plt.figure(figsize=(8, 5))
    plt.plot(freqs, powers, marker='s', color='green')
    plt.title("Dynamic Power vs Frequency")
    plt.xlabel("Frequency (Hz)")
    plt.ylabel("Dynamic Power (W)")
    plt.grid(True)
    plt.tight_layout()
    plt.show()

def main():
    # Create a dummy gates.json for demonstration
    gate_library_data = {
      "INV": {
        "R": 1000,
        "C": 2e-15,
        "alpha": 0.5
      },
      "NAND2": {
        "R": 1500,
        "C": 3e-15,
        "alpha": 0.4
      },
      "NOR2": {
        "R": 1800,
        "C": 3.5e-15,
        "alpha": 0.3
      }
    }
    with open("gates.json", "w") as f:
        json.dump(gate_library_data, f)

    gates = load_gate_library()
    print("Available gates:", ', '.join(gates.keys()))
    gate_choice = input("Choose a gate: ").upper()

    node = int(input("Enter technology node (e.g., 180, 90, 45, 7): "))
    freq = float(input("Enter clock frequency (Hz): "))
    I_leak = float(input("Enter leakage current (A): "))

    scaling = get_scaling_factor(node)
    gate = gates.get(gate_choice)

    if gate:
        R = gate["R"] * scaling["R_scale"]
        C = gate["C"] * scaling["C_scale"]
        alpha = gate["alpha"]
        V = scaling["V"]
        leak_factor = scaling["leak_factor"]

        t_pd = calculate_delay(R, C)
        P_dyn = calculate_dynamic_power(alpha, C, V, freq)
        P_static = calculate_static_power(I_leak * leak_factor, V)

        print(f"\nðŸ“Š Results for {gate_choice} @ {node}nm:")
        print(f"Delay: {t_pd:.4e} s")
        print(f"Dynamic Power: {P_dyn:.4e} W")
        print(f"Static Power: {P_static:.4e} W")

        # Save
        results = [{
            "Gate": gate_choice,
            "Node (nm)": node,
            "Delay (s)": t_pd,
            "Dynamic Power (W)": P_dyn,
            "Static Power (W)": P_static
        }]
        save_to_csv(results)
        print("\nâœ… Results saved to results.csv")

        # Example multi-node delay plot (simulate across 180nm, 90nm, 45nm, 7nm)
        nodes_to_test = [180, 90, 45, 7]
        delay_plot_data = []

        for n in nodes_to_test:
            scale = get_scaling_factor(n)
            Rn = gate["R"] * scale["R_scale"]
            Cn = gate["C"] * scale["C_scale"]
            delay = calculate_delay(Rn, Cn)
            delay_plot_data.append({"Node (nm)": n, "Delay (s)": delay})

        plot_delay_vs_node(delay_plot_data)

        # Example frequency sweep for power plot
        freq_data = []
        for f in [1e6, 10e6, 50e6, 100e6, 500e6]:
            dyn_power = calculate_dynamic_power(alpha, C, V, f)
            freq_data.append({"Frequency (Hz)": f, "Dynamic Power (W)": dyn_power})

        plot_power_vs_frequency(freq_data)

    else:
        print("Gate not found!")

if __name__ == "__main__":
    main()
